<!DOCTYPE html>
<html>
<head>
    <title>Motion Profile Simulator</title>
    <style>
        .container {
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 1px solid #ccc;
            margin: 20px 0;
        }
        .stats {
            margin: 20px 0;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>Motion Profile with Input Shaping</h2>
        <canvas id="motionGraph" width="1200" height="700"></canvas>
        <div class="stats" id="stats"></div>
    </div>

    <script>
        const STEPS_PER_MM = 100;
        const MAX_VELOCITY = 50; // mm/s
        const ACCEL_STEPS = 100;
        const DECEL_STEPS = 100;
        const TOTAL_STEPS = 2000;
        const NATURAL_FREQUENCY = 55; // Hz
        const DAMPING_RATIO = 0.1;
        let profile = [];
        let currentTime = 0;
        let lastTime=0;
        let totalstep = 0;
        let samplerI =0;
        let samplerC =500;
        let acT=0;
        let acV=0;
        let a1=0;
        let a2=0;
        let oldV=0;
        class InputShaper {
            constructor(naturalFrequency, dampingRatio, method = 'ZV') {
                this.MICROS_TO_SECONDS = 1.0e-6;
                
                // Calculate common parameters
                const wd = Math.sqrt(1.0 - dampingRatio * dampingRatio); // Damped frequency
                const K = Math.exp(-dampingRatio * Math.PI / wd);
                const td = (1.0e+6) / (naturalFrequency*wd); // Damped period

                // Select shaper method
                switch (method.toUpperCase()) {
                    case 'ZV': // Zero Vibration
                        this.impulses = [
                            { amplitude: 1.0 , timeDelay: 0.0 },
                            { amplitude: K , timeDelay: td/2 }
                        ];
                        break;

                    case 'ZVD': // Zero Vibration and Derivative
                        const K2 = K * K;
                        this.impulses = [
                            { amplitude: 1.0 , timeDelay: 0.0 },
                            { amplitude: 2.0 * K , timeDelay: td/2 },
                            { amplitude: K2 , timeDelay: td }
                        ];
                        break;

                    case 'UMZV': // Extra-Insensitive
                         a1 = 1-1/Math.sqrt(2);
                         a2 = (Math.sqrt(2)-1)*K;
                        
                        this.impulses = [
                            { amplitude: a1, timeDelay: 0.0 },
                            { amplitude: a2, timeDelay: td*0.375 },
                            { amplitude: a1*K*K, timeDelay: td*0.75 }
                        ];
                        break;

                    case 'EI': // Unity-Magnitude Zero Vibration
                        const v_tol=0.05;
                        a1=0.25*(1+v_tol);
                        a2=0.5*(1-v_tol)*K;
                        this.impulses = [
                            { amplitude: a1, timeDelay: 0.0 },
                            { amplitude: a2, timeDelay: td/2 },
                            { amplitude: a1*K*K, timeDelay: td }
                        ];
                        break;

                    default:
                        console.warn(`Unknown shaper method: ${method}. Defaulting to ZV.`);
                        this.impulses = [
                            { amplitude: 1.0 / (1.0 + K), timeDelay: 0.0 },
                            { amplitude: K / (1.0 + K), timeDelay: td }
                        ];
                }

                        // Setup circular buffer
                this.maxDelay = this.impulses[this.impulses.length - 1].timeDelay * 1.6;
                this.bufferSize = Math.ceil(this.maxDelay / samplerC) + 2;
                this.history = new Array(this.bufferSize);
                this.head = 0;  // Write position
                this.tail = 0;  // Oldest entry position
                this.count = 0; // Number of valid entries
            }
            shapeVelocity(velocity) {
                if (velocity <= 0) return 0.0;

                const stepTime = 1.0e+6/(STEPS_PER_MM*velocity);
                
                // Accumulate samples
                samplerI++;
                acV += velocity * stepTime;
                acT += stepTime;
                
                if (acT >= samplerC) {
                    // Add new entry to circular buffer
                    this.history[this.head] = {
                        velocity: acV/acT,
                        timeStamp: currentTime + (acT/samplerI)
                    };
                    
                    this.head = (this.head + 1) % this.bufferSize;
                    if (this.count < this.bufferSize) {
                        this.count++;
                    } else {
                        this.tail = (this.tail + 1) % this.bufferSize;
                    }
                    
                    samplerI = 0;
                    acV = 0;
                    acT = 0;
                }

                // Remove old entries
                const cutoffTime = currentTime - this.maxDelay;
                while (this.count > 0 && this.history[this.tail].timeStamp < cutoffTime) {
                    this.tail = (this.tail + 1) % this.bufferSize;
                    this.count--;
                }

                let shapedVelocity = 0.0;
                let totalWeight = 0.0;

                for (const impulse of this.impulses) {
                    const targetTime = currentTime - impulse.timeDelay;
                    
                    // Find entries in circular buffer
                    let beforeIndex = -1;
                    let afterIndex = -1;
                    
                    // Search through valid entries
                    let searchCount = 0;
                    let idx = this.tail;
                    while (searchCount < this.count) {
                        if (this.history[idx].timeStamp > targetTime) {
                            afterIndex = idx;
                            beforeIndex = ((idx - 1 + this.bufferSize) % this.bufferSize);
                            // Check if beforeIndex is valid
                            if (searchCount === 0) beforeIndex = -1;
                            break;
                        }
                        idx = (idx + 1) % this.bufferSize;
                        searchCount++;
                    }

                    if (beforeIndex >= 0 && afterIndex >= 0) {
                        const beforeEntry = this.history[beforeIndex];
                        const afterEntry = this.history[afterIndex];
                        
                        const timeFraction = (targetTime - beforeEntry.timeStamp) / 
                                        (afterEntry.timeStamp - beforeEntry.timeStamp);
                        const interpolatedVel = beforeEntry.velocity + 
                                            (afterEntry.velocity - beforeEntry.velocity) * timeFraction;
                        
                        shapedVelocity += impulse.amplitude * interpolatedVel;
                        totalWeight += impulse.amplitude;
                    } else if (this.count > 0) {
                        // Use nearest available entry
                        const nearestIdx = afterIndex >= 0 ? afterIndex : 
                                        ((this.head - 1 + this.bufferSize) % this.bufferSize);
                        shapedVelocity += impulse.amplitude * this.history[nearestIdx].velocity;
                        totalWeight += impulse.amplitude;
                    }
                }

                currentTime += stepTime;
                return totalWeight > 0 ? shapedVelocity / totalWeight : velocity;
            }

        }


        // Motion profile parameters


        // Create input shaper
        // Create shapers with different methods
        const zvShaper = new InputShaper(NATURAL_FREQUENCY, DAMPING_RATIO, 'ZV');
        const zvdShaper = new InputShaper(NATURAL_FREQUENCY, DAMPING_RATIO, 'ZVD');
        const eiShaper = new InputShaper(NATURAL_FREQUENCY, DAMPING_RATIO, 'EI');
        const umzvShaper = new InputShaper(NATURAL_FREQUENCY, DAMPING_RATIO, 'UMZV');

        // Use them in your profile generation
        const shaper = umzvShaper; // Choose which shaper to use
        // Generate motion profile

        function generateProfile({
            entryVel = 0,          // Initial velocity (mm/s)
            accelSteps = 100,      // Number of steps for acceleration
            nominalVel = 50,       // Target/nominal velocity (mm/s)
            exitVel = 0,           // Final velocity (mm/s)
            decelSteps = 100,      // Number of steps for deceleration
            totalSteps = 2000      // Total steps in profile
        }) {
            let step = 0;
            
            // Calculate acceleration parameters
            const entryVelSquared = entryVel * entryVel;
            const nominalVelSquared = nominalVel * nominalVel;
            const exitVelSquared = exitVel * exitVel;
            
            // Calculate acceleration and deceleration rates
            const accel = (nominalVelSquared - entryVelSquared) / (accelSteps);
            const decel = (nominalVelSquared - exitVelSquared) / (decelSteps);
            
            let velSquared = entryVelSquared;  // Start from entry velocity

            while (step < totalSteps) {
                // Calculate target velocity based on motion phase
                let targetVel;
                if (step < accelSteps) {
                    // Acceleration phase
                    velSquared += accel;
                    targetVel = Math.sqrt(velSquared);
                } else if (step > totalSteps - decelSteps) {
                    // Deceleration phase
                    velSquared -= decel;
                    targetVel = Math.sqrt(Math.max(exitVelSquared, velSquared));  // Don't go below exit velocity
                } else {
                    // Constant velocity phase
                    targetVel = nominalVel;
                    velSquared = nominalVelSquared;
                }

                // Apply input shaping
                lastTime = currentTime;
                const shapedVel = shaper.shapeVelocity(targetVel);
                
                // Calculate acceleration from velocity difference
                const acceleration = profile.length > 0 
                    ? (shapedVel - profile[profile.length-1].shapedVelocity) / 
                    ((currentTime - profile[profile.length-1].time) * 1.0e-6)  // Convert microseconds to seconds
                    : 0;
                
                profile.push({
                    step: totalstep + step,
                    time: lastTime,
                    targetVelocity: targetVel,
                    shapedVelocity: shapedVel,
                    acceleration: acceleration  // Add acceleration to profile
                });

                step++;
            }
            totalstep=step;

        }

                // Update drawProfile function to include acceleration
        function drawProfile(profile) {
            const canvas = document.getElementById('motionGraph');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            ctx.clearRect(0, 0, width, height);

            // Calculate scales including acceleration
            const maxTime = profile[profile.length - 1].time;
            const maxVel = Math.max(...profile.map(p => Math.max(p.targetVelocity, p.shapedVelocity)));
            const maxAcc = Math.max(...profile.map(p => Math.abs(p.acceleration)));
            
            const scaleX = (width - 60) / maxTime;
            const scaleY = (height - 60) / (maxVel*2);

            // Draw axes
            ctx.beginPath();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.moveTo(30, height - 30);
            ctx.lineTo(width - 20, height - 30);
            ctx.moveTo(30, height - 30);
            ctx.lineTo(30, 20);
            ctx.stroke();
            const smoothedAcc = profile.map((p, i) => {
                const windowSize = 50; // Number of samples to average
                const start = Math.max(0, i - windowSize + 1);
                const end = i + 1;
                const avgAcc = profile.slice(start, end).reduce((sum, p) => sum + p.acceleration, 0) / (end - start);
                return avgAcc;
            });
                           // Draw acceleration profile
            ctx.beginPath();
            ctx.strokeStyle = '#ccccff';
            ctx.lineWidth = 5;
            
            smoothedAcc.forEach((acc, i) => {
                const x = 30 + profile[i].time * scaleX;
                const y = height - 250 - acc * scaleY * 0.03;
                i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
            });
            ctx.stroke();

            // Draw target velocity profile
            ctx.beginPath();
            ctx.strokeStyle = '#aaff00';
            ctx.lineWidth = 4;
            profile.forEach((p, i) => {
                const x = 30 + p.time * scaleX;
                const y = height - 150 - p.targetVelocity * scaleY;
                i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
            });
            ctx.stroke();

            // Draw shaped velocity profile
            ctx.beginPath();
            ctx.strokeStyle = '#cc0000';
            ctx.lineWidth = 1;
            profile.forEach((p, i) => {
                const x = 30 + p.time * scaleX;
                const y = height - 150 - p.shapedVelocity * scaleY;
                i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
            });
            ctx.stroke();





            // Update legend
            ctx.textAlign = 'left';
            ctx.fillStyle = '#ccff00';
            ctx.fillRect(width - 150, 20, 20, 10);
            ctx.fillStyle = '#000';
            ctx.fillText('Target Velocity', width - 120, 30);
            
            ctx.fillStyle = '#cc0000';
            ctx.fillRect(width - 150, 40, 20, 10);
            ctx.fillStyle = '#000';
            ctx.fillText('Shaped Velocity', width - 120, 50);
            
            ctx.fillStyle = '#0000cc';
            ctx.fillRect(width - 150, 60, 20, 10);
            ctx.fillStyle = '#000';
            ctx.fillText('Acceleration', width - 120, 70);

            // Update stats display
            const stats = document.getElementById('stats');
            const maxAcceleration = Math.max(...profile.map(p => Math.abs(p.acceleration)));
            stats.innerHTML = `
                Total Steps: ${totalstep}<br>
                Total Distance: ${totalstep / STEPS_PER_MM} mm<br>
                Max Velocity: ${MAX_VELOCITY} mm/s<br>
                Max Acceleration: ${maxAcceleration.toFixed(2)} mm/s²<br>
                Total Time: ${(maxTime*1.0e-6).toFixed(3)} seconds<br>
                Natural Frequency: ${NATURAL_FREQUENCY} Hz<br>
                Damping Ratio: ${DAMPING_RATIO}<br>
                Buffer Size: ${shaper.bufferSize}
            `;
        }
        // Generate and draw the profile
        generateProfile({
            entryVel: 0,
            accelSteps: 100,
            nominalVel: MAX_VELOCITY,
            exitVel: MAX_VELOCITY/3,
            decelSteps: 350,
            totalSteps: 2500
        });
        generateProfile({
            entryVel: MAX_VELOCITY/3,
            accelSteps: 200,
            nominalVel: MAX_VELOCITY,
            exitVel: 0,
            decelSteps: 400,
            totalSteps: 3500
        });
        drawProfile(profile);
    </script>
</body>
</html>
